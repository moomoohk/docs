{"name":"SexGeekCodeCategory","qualifiedName":"geek_code/geek_code-v312.SexGeekCodeCategory","comment":"<p>Original documentation:</p>\n<pre><code>Geeks have traditionally had problems with sex (ie, they never have any). Because geeks are so wrapped up in their sexuality (or lack of sexuality for that matter), it is important that the geek be willing to quantify their sexual experiences.\n\nThis code also is used to denote the gender of the geek. Females use 'x' in this category, while males use 'y'. Those that do not wish to disclose their gender can use 'z'. For example:\n\n - x+ -- A female who has had sex\n - y+ -- A male who has had sex.\n - z+ -- A person (gender undisclosed) who has had sex.\n\nFor those persons who do not wish to give out any details of their sex life, the use of z? (where z is the gender code) will allow you to do so.\n\nz+++++\n I am Madonna\nz++++\n I have a few little rug rats to prove I've been there. Besides, with kids around, who has time for sex?\nz+++\n I'm married, so I can get it (theoretically) whenever I want.\nz++\n I was once referred to as 'easy'. I have no idea where that might have come from though.\nz+\n I've had real, live sex.\nz\n I've had sex. Oh! You mean with someone else? Then no.\nz-\n Not having sex by choice.\nz--\n Not having sex because I just can't get any...\nz---\n Not having sex because I'm a nun or a priest.\nz*\n I'm a pervert.\nz**\n I've been known to make perverts look like angels.\n!z\n Sex? What's that? I've had no sexual experiences.\nz?\n It's none of your business what my sex life is like (this is used to denote your gender only).\n!z+\n Sex? What's that? No experience, willing to learn!\n</code></pre>","isAbstract":false,"superclass":"geek_code/geek_code.ExtremeGeekCodeCategory","implements":[],"subclass":[],"variables":{},"inheritedVariables":{"code":{"name":"code","qualifiedName":"geek_code/geek_code.GeekCodeCategory.code","comment":"<p><a>dart:core.String</a> representation of this category.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart:core.String","inner":[]}],"annotations":[]}},"methods":{"setters":{},"getters":{},"constructors":{"":{"name":"","qualifiedName":"geek_code/geek_code-v312.SexGeekCodeCategory.SexGeekCodeCategory-","comment":"<p>See GeekCodeCategory.GeekCodeCategory for a description of the parameters.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"builder":{"name":"builder","optional":false,"named":false,"default":false,"type":[{"outer":"geek_code/geek_code-v312.SexGeekCodeCategoryBuilder","inner":[]}],"value":null,"annotations":[]},"grade":{"name":"grade","optional":false,"named":false,"default":false,"type":[{"outer":"geek_code/geek_code-v312.GeekCodeGrade","inner":[]}],"value":null,"annotations":[]},"gender":{"name":"gender","optional":false,"named":false,"default":false,"type":[{"outer":"geek_code/geek_code-v312.Gender","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"operators":{},"methods":{}},"inheritedMethods":{"setters":{},"getters":{"grade":{"name":"grade","qualifiedName":"geek_code/geek_code-v312.SexGeekCodeCategory.grade","comment":"<p>Returns this category's grade.</p>","commentFrom":"","inheritedFrom":"geek_code.BasicGeekCodeCategory.grade","static":false,"abstract":false,"constant":false,"return":[{"outer":"geek_code/geek_code-v312.GeekCodeGrade","inner":[]}],"parameters":{},"annotations":[]},"hashCode":{"name":"hashCode","qualifiedName":"geek_code/geek_code-v312.SexGeekCodeCategory.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>geek_code/geek_code-v312.SexGeekCodeCategory.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart:core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"geek_code/geek_code-v312.SexGeekCodeCategory.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart:core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"geek_code/geek_code-v312.SexGeekCodeCategory.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart:core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>geek_code/geek_code-v312.SexGeekCodeCategory.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>geek_code/geek_code-v312.SexGeekCodeCategory.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart:core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"geek_code/geek_code-v312.SexGeekCodeCategory.noSuchMethod","comment":"<p><a>geek_code/geek_code-v312.SexGeekCodeCategory.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>geek_code/geek_code-v312.SexGeekCodeCategory.noSuchMethod</a> in an <a>dart:core.Invocation</a>.\nIf <a>geek_code/geek_code-v312.SexGeekCodeCategory.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>geek_code/geek_code-v312.SexGeekCodeCategory.noSuchMethod</a> is to throw a\n<a>dart:core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart:core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"geek_code/geek_code-v312.SexGeekCodeCategory.toString","comment":"","commentFrom":"","inheritedFrom":"geek_code.ExtremeGeekCodeCategory.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}